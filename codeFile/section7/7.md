# section7 정리

## 정렬

각 정렬을 오름차순 기준으로 정리해보자.

- `선택 정렬`: 데이터에서 최솟값을 앞으로 보내는 과정을 반복하는 정렬 방법이다. 시간복잡도 O(N^2)로 다소 비효율적인 방법이다.

첫번째 원소부터 마지막 원소까지 돌며 최솟값을 찾아낸 뒤, 그 값을 첫번쩨 원소와 교환하고 정렬을 확정한다. 확정된 정렬을 제외하고 나머지 원소 배열에서 이 과정을 반복한다.

(예시)
3 5 4 1 2
1 5 4 3 2 -> 1 확정
1 2 4 3 5 -> 1, 2 확정
...

- `버블 정렬`: 옆에 있는 데이터와 비교해서 더 작은 값을 앞으로 보낸다. 시간복잡도 O(N^2)로 연산수가 가장 많은 알고리즘으로 효율이 떨어지는 방법이다.

(예시)
3 5 4 1 2
3 4 5 1 2
3 4 1 5 2x
3 4 1 2 5 -> 가장 큰 수인 5가 확정됨
...

확정된 정렬을 제외하고 위와 같은 방법을 반복한다.

- `삽입 정렬`: 앞, 뒤 데이터와의 크기를 비교해 데이터를 적절한 위치에 삽입한다. 시간복잡도 O(N^2)이지만, 연산 수가 적어 앞 정렬 방식보다 효율적이다고 이야기 할 수 있다. 특히 이미 정렬되어 있는 데이터가 있다면 더 효율적이다.

(예시)
3 5 4 1 2 //3과 5는 이미 크기순으로 정렬되어있음
3 4 5 1 2 //4는 3과 5 사이에 삽입되어야 함
1 3 4 5 2 //1은 제일 앞에 삽입되어야 함
...

- `퀵 정렬`: 특정 데이터를 기준으로 큰 데이터와 작은 데이터를 서로 교환한 후 배열을 두 집합으로 나눈다. 기준이 되는 특정한 데이터를 Pivot이라고 하는데 일반적으로 첫번째 원소를 먼저 피봇으로 지정한다.
오름차순 정렬을 생각해보면, 피봇을 기준으로 왼쪽으로는 피봇보다 큰 데이터, 오른쪽으로는 피봇보다 작은 데이터를 찾고 둘을 교환한다.

일반적으로 사용되고 있는 빠른 정렬 알고리즘 중 하나이다.

(예시)
3 5 4 1 2 //3을 기준으로 (->)왼쪽에서는 피봇보다 큰 5, (<-)오른쪽에서는 피봇보다 작은 2 가 교환된다.
3 2 4 1 5
3 2 1 4 5 //한번 교차하게 되면 그룹을 나누는 과정이 끝나면 교차하는 지점의 최솟값을 피봇과 교환함
1 2 3 4 5 


- `병합 정렬`

- `힙 정렬`: 완전 이진트리 기반의 트리형 자료구조로, 최댓값이나 최솟값을 찾아내기 위해 보통 쓰이고, 힙에는 최대힙과 최소힙이 존재한다.  시간 복잡도는 O(N * logN)이다.(힙 생성 알고리즘 시간 복잡도*전체 데이터 수)

===
### 사용 메서드

1. `unshift(x)`: 배열의 맨 앞에 x라는 요소 추가

2. `splice(인덱스,0,x)`: 배열의 해당 인덱스에 x라는 요소가 삽입됨. (중간의 0은  배열에서 삭제할 요소의 개수이다)
## 그리디 알고리즘(탐욕법)

그리디 알고리즘은 간단한 문제 해결에 동적 프로그래밍을 사용하면 너무 많은 계산을 해야한다는 문제점을 해결하기 위해 고안되었다.

현 상황에서 가장 좋은, 최선의 선택을 고르는 알고리즘인데, 이 가장 좋은 선택은 최적해를 보장해주는 것은 아니다.

그리디 알고리즘을 사용하기 위한 조건 두가지가 있는데,

1) 탐욕스러운 선택 조건, 항상 안전해야 한다.
- 이 알고리즘에서 "안전하다"라는 것은 그리디 알고리즘으로 문제의 최적해를 반드시 도출할 수 있어야 한다는 것이다.

최적해가 반드시 나온다는 보장은 할 수 없지만, 그리디 알고리즘을 사용하면 최적해가 나올 수 있어야 하는 문제여야 한다.

2) 최적 부분 구조 조건
- 문제에 대한 최종 해결 방법이 부분 문제에 대해서도 또한 최적의 해결 방법이다라는 조건이다. 문제 해결의 여러 단계 중 하나의 단계에 대해 최적해가 도출되어야 한다.



## 3. 결정 알고리즘

