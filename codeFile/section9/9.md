# section9 정리
## 그래프와 인접 행렬

`그래프`: 노드/정점(V)과 간선(E)로 이루어진 자료구조 -> G(V,E)로 나타낸다.

이 그래프는 이차원 배열로 이루어진 `인접행렬`로 표현된다. (정점마다 해당 정점으로 나가는 간선의 정보를 저장함)

인접행렬 graph는 초기값이 모두 0으로 이루어져있다.

1. 무방향 그래프: 무방향, 혹은 양방향으로 해석하기도 한다.(간선을 통해 양쪽 정점에 서로 접근할 수 있음)

양방향 간선을 표현하기 위해서 행렬 체크는 다음과 같이 한다. (a와 b는 노드 번호이다. a와 b 사이에 간선 존재함.)

```JS
graph[a][b]=1;
graph[b][a]=1;
```

2. 방향 그래프: 한 노드에서 다른 노드로 이동하는 방향이 정해져 있다. 

노드 a->b로 간선이 이어져 있을 때 행렬 체크는 다음과 같이 한다.

```JS
graph[a][b]=1;
```

3. 가중치 방향 그래프: 방향이 나타나 있는 간선에 가중치 값도 포함되어 있는 경우를 가중치 방향 그래프라고 한다.(예를 들어 문제에서 비용을 표시하고 싶을 때 가중치를 사용한다)

노드 a->b로 간선이 이어져있고 가중치 값이 c인 경우

```JS
graph[a][b]=c;
```

## 경로 탐색

- 노드 개수가 적을 때(DFS `인접행렬`:9-2) : 노드(정점)의 개수가 적으면 위처럼 graph 행렬에 값을 담아 탐색하며 문제를 해결할 수 있다.

```JS
function solution(n, arr){ 
    let answer=0; //총 가짓수
    let path=[];
    let graph=Array.from(Array(n+1),()=>Array(n+1).fill(0));
    let check=Array.from({length:n+1},()=>0); 
    for(let [a,b] of arr) graph[a][b]=1; // 방향 그래프
    function DFS(v){ //1~n
        if(v===n){
            answer++;
            console.log(path); //경로 출력하기
        }
        else{
            for(let i=1;i<=n;i++){ //1~n * 1~n까지 확인
                if(graph[v][i]===1&&check[i]===0){
                    check[i]=1; //노드를 지나갈때 check
                    path.push(i);
                    DFS(i);
                    check[i]=0; //탐색하고 나오면서 check 품
                    path.pop();
                }
            }
        }
    }
    path.push(1);
    check[1]=1; //주의: DFS 시작하기 전에 1로 체크를 해주고 시작해야함
    DFS(1);
    return answer;
}

let arr=[[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 5], [3, 4], [4, 2], [4, 5]];
console.log(solution(5, arr));
```

- 노드 개수가 많을 때(DFS `인접리스트`:9-3) : 노드 개수가 많다면 행렬을 이용해 문제를 해결하는 것은 낭비이다. 인접행렬 방식을 사용하면 1~N개의 노드들을 다 돌면서 체크해줘야 해서 N이 커질수록 시간복잡도가 급격히 증가하는 것을 확인할 수 있다. 
인접 리스트 방식은 각 노드와 연결되어있는 노드들의 번호를 순서대로 저장해두는 방식이다.
```JS
function solution(n, arr){ 
    let answer=0; //총 가짓수
    let path=[];
    let graph=Array.from(Array(n+1),()=>Array()); //행은 n+1개, 빈 배열을 각 열에 넣어줌
    let check=Array.from({length:n+1},()=>0); 
    for(let [a,b] of arr) graph[a].push(b); // 인접리스트 사용하는 법
    function DFS(v){ //1~n
        if(v===n){
            answer++;
            console.log(path); //경로 출력하기
        }
        else{
            for(let i=0;i<=graph[v].length;i++){ 
                let nd = graph[v][i];
                if(check[nd]===0){
                    check[nd]=1;
                    path.push(nd);
                    DFS(nd);
                    check[nd]=0;
                    path.pop();
                }
            }
        }
    }
    path.push(1);
    check[1]=1; //주의: DFS 시작하기 전에 1로 체크를 해주고 시작해야함
    DFS(1);
    return answer;
}

let arr=[[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 5], [3, 4], [4, 2], [4, 5]];
console.log(solution(5, arr));
/*
인접리스트 담기 -> 인접 행렬과 차이점 파악하기

id 0 1 2 3 4 5
   ============
 1 2 3 4
 2 1 3 5
 3 4
 4 2 5  
*/
```
## BFS(넓이 우선 탐색)

넓이 우선 탐색은 루트 노드에서 인접 노드를 먼저 탐색하는 탐색 방법이다. 두 노드 사이의 최단 경로를 찾을 때 사용한다.

- 두 개의 `큐`로 해결: 선입선출 방식 이용, 어느 정점을 방문했는지 체크해야 함.


## BFS 풀이